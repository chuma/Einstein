// ==============================
// File:			TFLSettings
// Project:			Einstein
//
// Copyright 2003-2007 by Paul Guyot (pguyot@kallisys.net).
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
// ==============================
// $Id$
// ==============================

// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include "TFLSettings.h"
#include "Resources/icons/EinsteinApp64.fl.h"
#include "TFLApp.h"
#include "Version.h"
#if TARGET_OS_WIN32
#include "winsock2.h"
typedef SOCKET _the_tcp_socket;
#endif
#if TARGET_OS_LINUX
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define closesocket close
typedef int _the_tcp_socket;
#endif
static FILE *fROM; 
_the_tcp_socket sData;
#include <stdlib.h>
#include <string.h>
#include <FL/Fl_Native_File_Chooser.H>
#include <FL/Fl_Preferences.H>
static const char* prefVendor = "kallisys.net"; 
static const char* prefAppName = "einstein"; 
static Fl_Window *wProgressWindow = 0L; 
static int recvd; 

static void cb_TFLSettings(Fl_Window*, void* v) {
  TFLSettings *me = (TFLSettings*)v;
me->revertDialog();
me->redraw();
me->hide();
}

void TFLSettings::cb_Install_i(Fl_Menu_*, void*) {
  app->menuInstallPackage();
}
void TFLSettings::cb_Install(Fl_Menu_* o, void* v) {
  ((TFLSettings*)(o->parent()))->cb_Install_i(o,v);
}

void TFLSettings::cb_Backlight_i(Fl_Menu_*, void*) {
  app->menuBacklight();
}
void TFLSettings::cb_Backlight(Fl_Menu_* o, void* v) {
  ((TFLSettings*)(o->parent()))->cb_Backlight_i(o,v);
}

void TFLSettings::cb_Settings_i(Fl_Menu_*, void*) {
  app->menuShowSettings();
}
void TFLSettings::cb_Settings(Fl_Menu_* o, void* v) {
  ((TFLSettings*)(o->parent()))->cb_Settings_i(o,v);
}

void TFLSettings::cb_About_i(Fl_Menu_*, void*) {
  app->menuAbout();
}
void TFLSettings::cb_About(Fl_Menu_* o, void* v) {
  ((TFLSettings*)(o->parent()))->cb_About_i(o,v);
}

void TFLSettings::cb_Power_i(Fl_Menu_*, void*) {
  app->menuPower();
}
void TFLSettings::cb_Power(Fl_Menu_* o, void* v) {
  ((TFLSettings*)(o->parent()))->cb_Power_i(o,v);
}

Fl_Menu_Item TFLSettings::menu_RMB[] = {
 {"Install Package...", 0,  (Fl_Callback*)TFLSettings::cb_Install, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"Backlight", 0,  (Fl_Callback*)TFLSettings::cb_Backlight, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"Reset", 0,  0, 0, 81, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"Soft Reset", 0,  0, 0, 1, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"Deep Reset", 0,  0, 0, 1, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"Reset w/o Extensions", 0,  0, 0, 1, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"Power Drain Reset", 0,  0, 0, 1, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"Hard Reset (Brain Wipe)", 0,  0, 0, 1, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"Cold Boot", 0,  0, 0, 1, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Settings...", 0,  (Fl_Callback*)TFLSettings::cb_Settings, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"About...", 0,  (Fl_Callback*)TFLSettings::cb_About, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"Power", 0,  (Fl_Callback*)TFLSettings::cb_Power, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {0,0,0,0,0,0,0,0,0}
};

void TFLSettings::cb_wROMDownload_i(Fl_Button*, void*) {
  app->menuDownloadROM();
}
void TFLSettings::cb_wROMDownload(Fl_Button* o, void* v) {
  ((TFLSettings*)(o->parent()->parent()))->cb_wROMDownload_i(o,v);
}

void TFLSettings::cb_wROMPathChoose_i(Fl_Button*, void*) {
  Fl_Native_File_Chooser romPathChooser;
romPathChooser.title("Choose ROM file");
romPathChooser.preset_file(wROMPath->label());

switch(romPathChooser.show())
{
    case -1:
    case 1:
    	return;
    	break;
    default:
    	const char* path = romPathChooser.filename();
    	wROMPath->copy_label(path);
    	break;
};
}
void TFLSettings::cb_wROMPathChoose(Fl_Button* o, void* v) {
  ((TFLSettings*)(o->parent()->parent()))->cb_wROMPathChoose_i(o,v);
}

void TFLSettings::cb_wMachineChoice_i(Fl_Choice* o, void*) {
  char buf[FL_PATH_MAX];
strcpy(buf, wROMPath->label());
char *name = (char*)fl_filename_name(buf);
if (name) {
  strcpy(name, (char*)o->menu()[o->value()].user_data());
  wROMPath->copy_label(buf);
  wROMPath->redraw();
};
}
void TFLSettings::cb_wMachineChoice(Fl_Choice* o, void* v) {
  ((TFLSettings*)(o->parent()->parent()))->cb_wMachineChoice_i(o,v);
}

Fl_Menu_Item TFLSettings::menu_wMachineChoice[] = {
 {"MP2x00 US", 0,  0, (void*)("717006"), 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"MP2100 D", 0,  0, (void*)("737041"), 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"eMate 300", 0,  0, (void*)("747129"), 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {0,0,0,0,0,0,0,0,0}
};

void TFLSettings::cb_wFlashPathChoose_i(Fl_Button*, void*) {
  Fl_Native_File_Chooser flashPathChooser;
flashPathChooser.title("Choose Flash file");
flashPathChooser.preset_file(wFlashPath->label());

switch(flashPathChooser.show())
{
    case -1:
    case 1:
    	return;
    	break;
    default:
    	const char* path = flashPathChooser.filename();
    	wFlashPath->copy_label(path);
    	break;
};
}
void TFLSettings::cb_wFlashPathChoose(Fl_Button* o, void* v) {
  ((TFLSettings*)(o->parent()->parent()))->cb_wFlashPathChoose_i(o,v);
}

void TFLSettings::cb_wRAMSize_i(Fl_Slider*, void*) {
  updateRAMSizeLabel();
}
void TFLSettings::cb_wRAMSize(Fl_Slider* o, void* v) {
  ((TFLSettings*)(o->parent()->parent()))->cb_wRAMSize_i(o,v);
}

void TFLSettings::cb_wQuit_i(Fl_Button*, void*) {
  exit(0);
}
void TFLSettings::cb_wQuit(Fl_Button* o, void* v) {
  ((TFLSettings*)(o->parent()))->cb_wQuit_i(o,v);
}

void TFLSettings::cb_wStart_i(Fl_Button*, void*) {
  applyDialog();
savePreferences();
hide();
}
void TFLSettings::cb_wStart(Fl_Button* o, void* v) {
  ((TFLSettings*)(o->parent()))->cb_wStart_i(o,v);
}

void TFLSettings::cb_wRevert_i(Fl_Button*, void*) {
  revertDialog();
redraw();
}
void TFLSettings::cb_wRevert(Fl_Button* o, void* v) {
  ((TFLSettings*)(o->parent()))->cb_wRevert_i(o,v);
}

void TFLSettings::cb_wSave_i(Fl_Button*, void*) {
  applyDialog();
savePreferences();
hide();
}
void TFLSettings::cb_wSave(Fl_Button* o, void* v) {
  ((TFLSettings*)(o->parent()))->cb_wSave_i(o,v);
}
TFLSettings::TFLSettings(int X, int Y, int W, int H, const char *L)
  : Fl_Window(X, Y, W, H, L) {
  _TFLSettings();
}

TFLSettings::TFLSettings(int W, int H, const char *L)
  : Fl_Window(0, 0, W, H, L) {
  clear_flag(16);
  _TFLSettings();
}

TFLSettings::TFLSettings()
  : Fl_Window(0, 0, 425, 400, "Einstein Platform Setup") {
  clear_flag(16);
  _TFLSettings();
}

void TFLSettings::_TFLSettings() {
this->box(FL_FLAT_BOX);
this->color(FL_LIGHT1);
this->selection_color(FL_BACKGROUND_COLOR);
this->labeltype(FL_NO_LABEL);
this->labelfont(0);
this->labelsize(14);
this->labelcolor(FL_FOREGROUND_COLOR);
this->callback((Fl_Callback*)cb_TFLSettings, (void*)(this));
this->align(Fl_Align(FL_ALIGN_CLIP|FL_ALIGN_INSIDE));
this->when(FL_WHEN_RELEASE);
{ RMB = new Fl_Menu_Button(0, 0, 10, 10, "RMB Menu");
  RMB->labelsize(12);
  RMB->hide();
  RMB->deactivate();
  RMB->menu(menu_RMB);
} // Fl_Menu_Button* RMB
{ Fl_Group* o = new Fl_Group(10, 30, 405, 95, "  ROM");
  o->box(FL_GTK_DOWN_BOX);
  o->labelsize(11);
  o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
  { wROMPath = new Fl_Box(15, 35, 395, 35);
    wROMPath->labelfont(1);
    wROMPath->labelsize(12);
    wROMPath->align(Fl_Align(196|FL_ALIGN_INSIDE));
  } // Fl_Box* wROMPath
  { wROMDownload = new Fl_Button(235, 70, 80, 20, "Download...");
    wROMDownload->labelsize(12);
    wROMDownload->callback((Fl_Callback*)cb_wROMDownload);
  } // Fl_Button* wROMDownload
  { wROMPathChoose = new Fl_Button(325, 70, 80, 20, "Choose...");
    wROMPathChoose->labelsize(12);
    wROMPathChoose->callback((Fl_Callback*)cb_wROMPathChoose);
  } // Fl_Button* wROMPathChoose
  { wMachineChoice = new Fl_Choice(280, 95, 125, 20, "Machine:");
    wMachineChoice->down_box(FL_BORDER_BOX);
    wMachineChoice->labelsize(12);
    wMachineChoice->callback((Fl_Callback*)cb_wMachineChoice);
    wMachineChoice->menu(menu_wMachineChoice);
  } // Fl_Choice* wMachineChoice
  o->end();
} // Fl_Group* o
{ Fl_Group* o = new Fl_Group(10, 145, 405, 70, "  Internal Flash File");
  o->box(FL_GTK_DOWN_BOX);
  o->labelsize(11);
  o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
  { wFlashPath = new Fl_Box(15, 150, 395, 35);
    wFlashPath->labelfont(1);
    wFlashPath->labelsize(12);
    wFlashPath->align(Fl_Align(196|FL_ALIGN_INSIDE));
  } // Fl_Box* wFlashPath
  { wFlashPathChoose = new Fl_Button(325, 185, 80, 20, "Choose...");
    wFlashPathChoose->labelsize(12);
    wFlashPathChoose->callback((Fl_Callback*)cb_wFlashPathChoose);
  } // Fl_Button* wFlashPathChoose
  o->end();
} // Fl_Group* o
{ Fl_Group* o = new Fl_Group(10, 235, 200, 120, "  Screen");
  o->box(FL_GTK_DOWN_BOX);
  o->labelsize(11);
  o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
  { wWidth = new Fl_Int_Input(20, 245, 80, 20);
    wWidth->type(2);
    wWidth->labelsize(12);
    wWidth->textsize(12);
  } // Fl_Int_Input* wWidth
  { wHeight = new Fl_Int_Input(115, 245, 80, 20, "x ");
    wHeight->type(2);
    wHeight->labelsize(12);
    wHeight->textsize(12);
  } // Fl_Int_Input* wHeight
  { wFullScreen = new Fl_Check_Button(20, 270, 175, 20, "Full screen");
    wFullScreen->down_box(FL_DOWN_BOX);
    wFullScreen->labelsize(12);
  } // Fl_Check_Button* wFullScreen
  { wHideMouse = new Fl_Check_Button(20, 290, 175, 20, "Hide mouse pointer");
    wHideMouse->down_box(FL_DOWN_BOX);
    wHideMouse->labelsize(12);
  } // Fl_Check_Button* wHideMouse
  { wUseMonitor = new Fl_Check_Button(20, 310, 175, 20, "Debug Terminal");
    wUseMonitor->down_box(FL_DOWN_BOX);
    wUseMonitor->labelsize(12);
    wUseMonitor->deactivate();
  } // Fl_Check_Button* wUseMonitor
  o->end();
} // Fl_Group* o
{ Fl_Group* o = new Fl_Group(215, 235, 200, 80, "  Memory");
  o->box(FL_GTK_DOWN_BOX);
  o->labelsize(11);
  o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
  { Fl_Box* o = new Fl_Box(225, 250, 55, 20, "RAM Size");
    o->labelsize(11);
    o->align(Fl_Align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE));
  } // Fl_Box* o
  { wRAMSizeMB = new Fl_Box(280, 250, 18, 20, "4");
    wRAMSizeMB->labelsize(11);
    wRAMSizeMB->align(Fl_Align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE));
  } // Fl_Box* wRAMSizeMB
  { Fl_Box* o = new Fl_Box(297, 250, 20, 20, "MB");
    o->labelsize(11);
    o->align(Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE));
  } // Fl_Box* o
  { wRAMSizeKB = new Fl_Box(320, 250, 25, 20, "0");
    wRAMSizeKB->labelsize(11);
    wRAMSizeKB->align(Fl_Align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE));
    wRAMSizeKB->hide();
  } // Fl_Box* wRAMSizeKB
  { wRAMSizeKBLabel = new Fl_Box(345, 250, 20, 20, "KB");
    wRAMSizeKBLabel->labelsize(11);
    wRAMSizeKBLabel->align(Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE));
    wRAMSizeKBLabel->hide();
  } // Fl_Box* wRAMSizeKBLabel
  { wRAMSize = new Fl_Slider(225, 275, 180, 20);
    wRAMSize->type(1);
    wRAMSize->minimum(1);
    wRAMSize->maximum(255);
    wRAMSize->step(1);
    wRAMSize->value(64);
    wRAMSize->callback((Fl_Callback*)cb_wRAMSize);
  } // Fl_Slider* wRAMSize
  o->end();
} // Fl_Group* o
{ wDontShow = new Fl_Check_Button(215, 320, 150, 20, "Don\'t show at startup");
  wDontShow->down_box(FL_DOWN_BOX);
  wDontShow->labelsize(12);
} // Fl_Check_Button* wDontShow
{ wSoundEnabled = new Fl_Check_Button(215, 340, 70, 15, "Sound");
  wSoundEnabled->down_box(FL_DOWN_BOX);
  wSoundEnabled->value(1);
  wSoundEnabled->labelsize(12);
} // Fl_Check_Button* wSoundEnabled
{ wQuit = new Fl_Button(215, 365, 95, 25, "Quit");
  wQuit->color(FL_LIGHT1);
  wQuit->labelsize(12);
  wQuit->callback((Fl_Callback*)cb_wQuit);
} // Fl_Button* wQuit
{ wStart = new Fl_Button(320, 365, 95, 25, "Start");
  wStart->color(FL_LIGHT1);
  wStart->labelsize(12);
  wStart->callback((Fl_Callback*)cb_wStart);
} // Fl_Button* wStart
{ wRestartWarning = new Fl_Box(10, 365, 200, 25, "Changes only apply after restarting emulator");
  wRestartWarning->labelfont(1);
  wRestartWarning->labelsize(12);
  wRestartWarning->align(Fl_Align(132|FL_ALIGN_INSIDE));
  wRestartWarning->hide();
} // Fl_Box* wRestartWarning
{ wRevert = new Fl_Button(215, 365, 95, 25, "Revert");
  wRevert->color(FL_LIGHT1);
  wRevert->labelsize(12);
  wRevert->callback((Fl_Callback*)cb_wRevert);
  wRevert->hide();
} // Fl_Button* wRevert
{ wSave = new Fl_Button(320, 365, 95, 25, "Save");
  wSave->color(FL_LIGHT1);
  wSave->labelsize(12);
  wSave->callback((Fl_Callback*)cb_wSave);
  wSave->hide();
} // Fl_Button* wSave
set_non_modal();
end();
}

void TFLSettings::setApp(TFLApp *App) {
  app = App;
  
  setDefaultPaths();
  
  /*
  appPath = strdup(AppPath);
  char *end = (char*)fl_filename_name(appPath);
  if (end)
    *end = 0;
  */
}

void TFLSettings::loadPreferences() {
  char buf[FL_PATH_MAX];
  
  // Fl_Preferences prefs(Fl_Preferences::USER, prefVendor, prefAppName);
  Fl_Preferences prefs(configDirPath, prefVendor, prefAppName);
  
  // general preferences
  prefs.get("dontShow", dontShow, 0);
  prefs.get("soundEnabled", soundEnabled, 1);
  
  // ROM Preferences
  Fl_Preferences rom(prefs, "ROM");
  
  // strcpy(buf, appPath);
  strcpy(buf, dataDirPath);
  strcat(buf, "/717006");
  
  rom.get("path", ROMPath, buf);
  rom.get("machine", machine, 0);
  
  // Flash Preferences
  Fl_Preferences flash(prefs, "Flash");
  
  //prefs.getUserdataPath(buf, FL_PATH_MAX-15);
  strcpy(buf, dataDirPath);
  strcat(buf, "/internal.flash");
  flash.get("path", FlashPath, buf);
  
  // screen preferences
  Fl_Preferences screen(prefs, "Screen");
  screen.get("width", screenWidth, 320);
  screen.get("height", screenHeight, 480);
  screen.get("fullScreen", fullScreen, 0);
  screen.get("hideMouse", hideMouse, 0);
  screen.get("useMonitor", useMonitor, 0);
  
  // Memory preferences
  Fl_Preferences memory(prefs, "Memory");
  memory.get("RAMSize", RAMSize, 64);
}

void TFLSettings::savePreferences() {
  // Fl_Preferences prefs(Fl_Preferences::USER, prefVendor, prefAppName);
  Fl_Preferences prefs(configDirPath, prefVendor, prefAppName);
  
  // general preferences
  prefs.set("dontShow", dontShow);
  prefs.set("soundEnabled", soundEnabled);
  
  // ROM Preferences
  Fl_Preferences rom(prefs, "ROM");
  rom.set("path", ROMPath);
  rom.set("machine", machine);
  
  // Flash Preferences
  Fl_Preferences flash(prefs, "Flash");
  flash.set("path", FlashPath);
  
  // screen preferences
  Fl_Preferences screen(prefs, "Screen");
  screen.set("width", screenWidth);
  screen.set("height", screenHeight);
  screen.set("fullScreen", fullScreen);
  screen.set("hideMouse", hideMouse);
  screen.set("useMonitor", useMonitor);
  
  // Memory preferences
  Fl_Preferences memory(prefs, "Memory");
  memory.set("RAMSize", RAMSize);
}

void TFLSettings::revertDialog() {
  char buf[32];
  
  wROMPath->copy_label(ROMPath);
  wMachineChoice->value(machine);
  
  wFlashPath->copy_label(FlashPath);
  
  sprintf(buf, "%d", screenWidth);
  wWidth->value(buf);
  sprintf(buf, "%d", screenHeight);
  wHeight->value(buf);
  wFullScreen->value(fullScreen);
  wHideMouse->value(hideMouse);
  wUseMonitor->value(useMonitor);
  
  wRAMSize->value(RAMSize);
  updateRAMSizeLabel();
  
  wDontShow->value(dontShow);
  wSoundEnabled->value(soundEnabled);
}

void TFLSettings::applyDialog() {
  free(ROMPath);
  ROMPath = strdup(wROMPath->label());
  machine = wMachineChoice->value();
  
  free(FlashPath);
  FlashPath = strdup(wFlashPath->label());
  
  screenWidth = atoi(wWidth->value());
  screenHeight = atoi(wHeight->value());
  fullScreen = wFullScreen->value();
  hideMouse = wHideMouse->value();
  useMonitor = wUseMonitor->value();
  
  RAMSize = (int)wRAMSize->value();
  
  dontShow = wDontShow->value();
  soundEnabled = wSoundEnabled->value();
}

void TFLSettings::runningMode() {
  wRestartWarning->show();
  wQuit->hide();
  wStart->hide();
  wRevert->show();
  wSave->show();
}

void TFLSettings::setDefaultPaths() {
  // configDirPath, dataDirPath
  
  // config: XDG_CONFIG_HOME, fall back to HOME/.einstein/
  // data: XDG_DATA_HOME, fall back to HOME/.einstein/
  
  char *cfghome = getenv("XDG_CONFIG_HOME");
  char *datahome = getenv("XDG_DATA_HOME");
  
  if (cfghome)
  {
      snprintf(configDirPath, FL_PATH_MAX, "%s", cfghome);
  }
  else
  {
      cfghome = getenv("HOME");
      snprintf(configDirPath, FL_PATH_MAX, "%s/.%s", cfghome, prefAppName);
  }
  
  if (datahome)
  {
      snprintf(dataDirPath, FL_PATH_MAX, "%s", datahome);
  }
  else
  {
      datahome = getenv("HOME");
      snprintf(dataDirPath, FL_PATH_MAX, "%s/.%s", datahome, prefAppName);
  }
}

void TFLSettings::updateRAMSizeLabel() {
  char buf[32];
  int ram = (int)(wRAMSize->value());
  int m = ram/16;
  sprintf(buf, "%d", m);
  wRAMSizeMB->copy_label(buf);
  
  int k = (ram*64)%1024;
  sprintf(buf, "%d", k);
  wRAMSizeKB->copy_label(buf);
  
  if (k==0) {
    wRAMSizeKB->hide();
    wRAMSizeKBLabel->hide();
  } else {
    wRAMSizeKB->show();
    wRAMSizeKBLabel->show();
  }
}

static void close_window_cb(Fl_Widget*, void *user) {
  Fl_Window *win = (Fl_Window*)user;
  win->hide();
}

Fl_Double_Window *wAbout=(Fl_Double_Window *)0;

Fl_Box *wAboutVersionBox=(Fl_Box *)0;

Fl_Double_Window* createAboutDialog() {
  { wAbout = new Fl_Double_Window(250, 180, "About");
    wAbout->callback((Fl_Callback*)close_window_cb, (void*)(wAbout));
    { Fl_Box* o = new Fl_Box(92, 5, 69, 75);
      o->image(&image_EinsteinApp64);
    } // Fl_Box* o
    { Fl_Box* o = new Fl_Box(32, 80, 190, 25, "Einstein");
      o->labelfont(1);
    } // Fl_Box* o
    { Fl_Button* o = new Fl_Button(190, 155, 55, 20, "Close");
      o->labelsize(12);
      o->callback((Fl_Callback*)close_window_cb, (void*)(wAbout));
    } // Fl_Button* o
    { Fl_Box* o = new Fl_Box(32, 104, 190, 20, "Emulating the Newton N2 Platform");
      o->labelsize(12);
    } // Fl_Box* o
    { Fl_Box* o = new Fl_Box(77, 125, 45, 20, "Version");
      o->labelsize(11);
    } // Fl_Box* o
    { Fl_Box* o = wAboutVersionBox = new Fl_Box(125, 125, 50, 20, "2018.1.1");
      wAboutVersionBox->labelsize(11);
      o->label(VERSION_STRING_SHORT);
    } // Fl_Box* wAboutVersionBox
    wAbout->end();
  } // Fl_Double_Window* wAbout
  return wAbout;
}

Fl_Double_Window *wROMDownloadWindow=(Fl_Double_Window *)0;

Fl_Int_Input *wDownloadIP3=(Fl_Int_Input *)0;

Fl_Int_Input *wDownloadIP2=(Fl_Int_Input *)0;

Fl_Int_Input *wDownloadIP1=(Fl_Int_Input *)0;

Fl_Int_Input *wDownloadIP0=(Fl_Int_Input *)0;

Fl_Int_Input *wDownloadPort=(Fl_Int_Input *)0;

Fl_Box *wDownloadPath=(Fl_Box *)0;

Fl_Button *wDownloadChoose=(Fl_Button *)0;

static void cb_wDownloadChoose(Fl_Button*, void*) {
  Fl_Native_File_Chooser romPathChooser;
romPathChooser.type(Fl_Native_File_Chooser::BROWSE_SAVE_FILE);
romPathChooser.title("Choose ROM file destination");
romPathChooser.preset_file(wDownloadPath->label());

switch(romPathChooser.show())
{
    case -1:
    case 1:
    	return;
    	break;
    default:
    	const char* path = romPathChooser.filename();
    	wDownloadPath->copy_label(path);
    	break;
};
}

static void cb_Cancel(Fl_Button* o, void*) {
  o->window()->hide();
}

static void cb_Download(Fl_Button*, void*) {
  if (!wProgressWindow) {
  wProgressWindow = createROMDownloadProgressWindow();
}
wProgressSlider->label("Connecting...");
wProgressSlider->value(0);
wProgressWindow->show();

startDump();
}

Fl_Double_Window* createROMDownloadDialog() {
  { wROMDownloadWindow = new Fl_Double_Window(415, 390, "Download ROM via TCP/IP");
    { Fl_Box* o = new Fl_Box(5, 5, 405, 25, "Downloading the Newton ROM using a network connection");
      o->labelfont(1);
      o->labelsize(12);
    } // Fl_Box* o
    { Fl_Box* o = new Fl_Box(20, 35, 370, 120, "* install ROMDumper.pkg on your Newton\n* tap the ROMDumper icon in your Extr\
as Drawer\n* tap Start\n* if your Newton is not connected to the network yet, \
choose a\n   connection method\n* copy the IP address and the port number into\
 the form below\n* choose a filename for your new ROM dump\n* click Download");
      o->labelsize(11);
      o->align(Fl_Align(133|FL_ALIGN_INSIDE));
    } // Fl_Box* o
    { Fl_Group* o = new Fl_Group(5, 170, 405, 70, "  TCP/IP Connection");
      o->box(FL_GTK_DOWN_BOX);
      o->labelsize(11);
      o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      { Fl_Group* o = new Fl_Group(160, 184, 145, 20, "IP Address:");
        o->box(FL_DOWN_BOX);
        o->color(FL_BACKGROUND2_COLOR);
        o->labelsize(12);
        o->align(Fl_Align(FL_ALIGN_LEFT));
        { wDownloadIP3 = new Fl_Int_Input(162, 186, 28, 16);
          wDownloadIP3->type(2);
          wDownloadIP3->box(FL_FLAT_BOX);
          wDownloadIP3->textsize(12);
        } // Fl_Int_Input* wDownloadIP3
        { wDownloadIP2 = new Fl_Int_Input(197, 186, 28, 16, ".");
          wDownloadIP2->type(2);
          wDownloadIP2->box(FL_FLAT_BOX);
          wDownloadIP2->textsize(12);
        } // Fl_Int_Input* wDownloadIP2
        { wDownloadIP1 = new Fl_Int_Input(232, 186, 28, 16, ".");
          wDownloadIP1->type(2);
          wDownloadIP1->box(FL_FLAT_BOX);
          wDownloadIP1->textsize(12);
        } // Fl_Int_Input* wDownloadIP1
        { wDownloadIP0 = new Fl_Int_Input(270, 186, 28, 16, ".");
          wDownloadIP0->type(2);
          wDownloadIP0->box(FL_FLAT_BOX);
          wDownloadIP0->textsize(12);
        } // Fl_Int_Input* wDownloadIP0
        o->end();
      } // Fl_Group* o
      { wDownloadPort = new Fl_Int_Input(160, 209, 80, 20, "Port:");
        wDownloadPort->type(2);
        wDownloadPort->labelsize(12);
        wDownloadPort->textsize(12);
      } // Fl_Int_Input* wDownloadPort
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(5, 260, 405, 70, "  ROM File Destination");
      o->box(FL_GTK_DOWN_BOX);
      o->labelsize(11);
      o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      { wDownloadPath = new Fl_Box(10, 265, 395, 35);
        wDownloadPath->labelfont(1);
        wDownloadPath->labelsize(12);
        wDownloadPath->align(Fl_Align(196|FL_ALIGN_INSIDE));
      } // Fl_Box* wDownloadPath
      { wDownloadChoose = new Fl_Button(320, 300, 80, 20, "Choose...");
        wDownloadChoose->labelsize(12);
        wDownloadChoose->callback((Fl_Callback*)cb_wDownloadChoose);
      } // Fl_Button* wDownloadChoose
      o->end();
    } // Fl_Group* o
    { Fl_Button* o = new Fl_Button(210, 355, 95, 25, "Cancel");
      o->color(FL_LIGHT1);
      o->labelsize(12);
      o->callback((Fl_Callback*)cb_Cancel);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(315, 355, 95, 25, "Download");
      o->color(FL_LIGHT1);
      o->labelsize(12);
      o->callback((Fl_Callback*)cb_Download);
    } // Fl_Button* o
    wROMDownloadWindow->set_modal();
    wROMDownloadWindow->end();
  } // Fl_Double_Window* wROMDownloadWindow
  return wROMDownloadWindow;
}

void startDump() {
  sData = INVALID_SOCKET;
  // open the file that we will dump the ROM into
  fROM = fopen(wDownloadPath->label(), "rb");
  if (fROM) {
    fclose(fROM);
    if (fl_choice("The file\n%s\nalready exists.\nDo you want to erase this file now?", "Yes", "No", 0, wDownloadPath->label() ))
    {
    	// 1 = No
    	wProgressWindow->hide();
    	return;
    }
  //  if (fl_ask("The file\n%s\nalready exists.\nDo you want to erase this file now?", wDownloadPath->label())==0) {
  //    wProgressWindow->hide();
  //    return;
  //  }
  }
  
  // erase the file now
  fROM = fopen(wDownloadPath->label(), "wb");
  if (!fROM) {
    fl_alert("The file\n%s\ncan not be written. Operation aborted.", wDownloadPath->label());
    wProgressWindow->hide();
    return;
  }
  fclose(fROM);
  
  Fl::flush();
  #if TARGET_OS_WIN32
  // open the WSA socket library
  WORD wVersionRequested;
  WSADATA wsaData;
  int err;
  wVersionRequested = MAKEWORD( 2, 2 );
  err = WSAStartup( wVersionRequested, &wsaData );
  if (err) {
    fl_alert("Can't start network communications.");
    wProgressWindow->hide();
    return;
  }
  #endif
  
  // open the socket itself
  sData = socket(AF_INET, SOCK_STREAM, 0);
  if (sData==INVALID_SOCKET) {
    fl_alert("Can't open network socket.");
    wProgressWindow->hide();
    return;
  }
  // read all TCP/IP settings from the dialog
  unsigned char ip3 = atoi(wDownloadIP3->value());
  unsigned char ip2 = atoi(wDownloadIP2->value());
  unsigned char ip1 = atoi(wDownloadIP1->value());
  unsigned char ip0 = atoi(wDownloadIP0->value());
  unsigned short port = atoi(wDownloadPort->value());
  // copy the data into the structures
  struct sockaddr_in host_addr;
  int addr_len = sizeof(host_addr);
  memset(&host_addr, 0, addr_len);
  host_addr.sin_family = AF_INET;
  host_addr.sin_port = htons(port);
  host_addr.sin_addr.s_addr = htonl((ip3<<24)|(ip2<<16)|(ip1<<8)|ip0);
  // now connect the socket to the Newton TCP/IP port
  wProgressCancel->deactivate();
  Fl::flush();
  if (::connect(sData, (struct sockaddr*)&host_addr, addr_len) == SOCKET_ERROR)
  {
    fl_alert("Can't connect socket to Newton.\nDid you start ROMdump?");
    closesocket(sData);
    sData = INVALID_SOCKET;
    wProgressWindow->hide();
    wProgressCancel->activate();
    return;
  }
  wProgressCancel->activate();
  // add callbacks that will be called when we receive data and when we lose the connection
  wProgressSlider->label("Downloading...");
  Fl::add_fd(sData, FL_READ, dataReadCB, 0);
  Fl::add_fd(sData, FL_EXCEPT, dataExceptCB, 0);
  fROM = fopen(wDownloadPath->label(), "wb");
  recvd = 0;
}

void dataReadCB(int p, void *user_data) {
  unsigned long n;
  
  #if TARGET_OS_WIN32
  DWORD rcvd;
  int ret = WSAIoctl(sData, FIONREAD, 0, 0, &n, sizeof(n), &rcvd, 0, 0);
  #else
  int ret = ioctl(sData, FIONREAD, &n);
  #endif
  
  if (ret || n==0) {
    dataExceptCB(p, user_data);
    return;
  }
  
  char *buf = (char*)malloc(n);
  
  int n1 = ::recv(sData, buf, n, 0);
  fwrite(buf, n, 1, fROM);
  free(buf);
  
  recvd += n;
  printf("Received %d/%d (%d)\n", n, n1, recvd);
  wProgressSlider->value(recvd/1024);
}

void dataExceptCB(int p, void *user_data) {
  if (fROM) {
    fclose(fROM);
    fROM = 0L;
  }
  if (sData!=INVALID_SOCKET) {
    closesocket(sData);
    Fl::remove_fd(sData);
    sData = INVALID_SOCKET;
  }
  wProgressWindow->hide();
  if (recvd==8*1024*1024) {
    fl_message("Complete ROM received.");
    wROMDownloadWindow->hide();
  } else {
    fl_message("Invalid ROM size.\n%d bytes expected, but %d bytes received.", 8*1024*1024, recvd);
  }
}

Fl_Slider *wProgressSlider=(Fl_Slider *)0;

Fl_Button *wProgressCancel=(Fl_Button *)0;

static void cb_wProgressCancel(Fl_Button* o, void*) {
  o->window()->hide();
}

Fl_Double_Window* createROMDownloadProgressWindow() {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = new Fl_Double_Window(285, 110);
    w = o; if (w) {/* empty */}
    { wProgressSlider = new Fl_Slider(10, 25, 265, 20, "Connecting...");
      wProgressSlider->type(3);
      wProgressSlider->labelsize(12);
      wProgressSlider->maximum(8192);
      wProgressSlider->align(Fl_Align(FL_ALIGN_TOP));
    } // Fl_Slider* wProgressSlider
    { wProgressCancel = new Fl_Button(180, 70, 95, 25, "Cancel");
      wProgressCancel->color(FL_LIGHT1);
      wProgressCancel->labelsize(12);
      wProgressCancel->callback((Fl_Callback*)cb_wProgressCancel);
    } // Fl_Button* wProgressCancel
    o->set_modal();
    o->end();
  } // Fl_Double_Window* o
  return w;
}

// ======================================================== //
// Of course the code works. It just compiled, didn't it?   //
// --helixcode123, 11/8/2001 on slashdot.                   //
// ======================================================== //


